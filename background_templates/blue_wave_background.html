<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŒŠ Flowing Wave Animation Background</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000510;
        }
        #animation-canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }
        
        /* Additional styling for enhanced visual experience */
        .performance-optimization {
            image-rendering: optimizeQuality;
        }
    </style>
</head>
<body>
    <div id="animation-canvas-container" class="performance-optimization"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js scene components
        const animationScene = new THREE.Scene();
        const mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const webGLRenderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true 
        });
        
        // Configure renderer settings
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.setClearColor(0x000510, 1);
        document.getElementById('animation-canvas-container').appendChild(webGLRenderer.domElement);

        // Create wave surface geometry with enhanced parameters
        const waveSurfaceGeometry = new THREE.PlaneGeometry(150, 150, 100, 100);
        const waveSurfaceMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                animationTime: { value: 0 } 
            },
            transparent: true,
            vertexShader: `
                uniform float animationTime;
                varying vec2 textureCoordinates;
                
                void main() {
                    textureCoordinates = uv;
                    vec3 vertexPosition = position;
                    
                    // Enhanced wave calculations with multiple frequencies
                    vertexPosition.z += sin(vertexPosition.x * 0.1 + animationTime * 0.8) * 3.0;
                    vertexPosition.z += cos(vertexPosition.y * 0.08 + animationTime * 0.6) * 2.5;
                    vertexPosition.z += sin(vertexPosition.x * 0.05 + vertexPosition.y * 0.05 + animationTime) * 1.5;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
                }
            `,
            fragmentShader: `
                uniform float animationTime;
                varying vec2 textureCoordinates;
                
                void main() {
                    vec2 coordinateUV = textureCoordinates;
                    
                    // Multi-layered wave pattern generation
                    float primaryWave = sin(coordinateUV.x * 6.0 + animationTime * 1.5);
                    float secondaryWave = cos(coordinateUV.y * 4.0 + animationTime * 1.2);
                    float flowPattern = sin(coordinateUV.x * 2.0 + coordinateUV.y * 2.0 + animationTime * 0.8);
                    
                    // Enhanced color palette for ocean waves
                    vec3 deepOcean = vec3(0.0, 0.1, 0.3);
                    vec3 mediumOcean = vec3(0.1, 0.4, 0.8);
                    vec3 lightOcean = vec3(0.4, 0.7, 1.0);
                    vec3 waveCrest = vec3(0.6, 0.9, 1.0);
                    
                    // Dynamic color blending based on wave patterns
                    vec3 finalColor = deepOcean + mediumOcean * primaryWave * secondaryWave;
                    finalColor += mix(lightOcean, waveCrest, flowPattern * 0.5 + 0.5) * 0.4;
                    
                    gl_FragColor = vec4(finalColor, 0.3 + flowPattern * 0.2);
                }
            `
        });

        // Create and position wave surface mesh
        const waveSurface = new THREE.Mesh(waveSurfaceGeometry, waveSurfaceMaterial);
        waveSurface.rotation.x = -Math.PI / 2;
        animationScene.add(waveSurface);

        // Configure camera position and orientation
        mainCamera.position.set(0, 35, 0.1);
        mainCamera.lookAt(0, 0, 0);

        // Animation timing and state management
        let animationTimeValue = 0;
        function runAnimationLoop() {
            requestAnimationFrame(runAnimationLoop);
            
            // Update animation time with smooth progression
            animationTimeValue += 0.01;
            waveSurfaceMaterial.uniforms.animationTime.value = animationTimeValue;
            
            // Dynamic camera movement for enhanced visual experience
            mainCamera.position.x = Math.sin(animationTimeValue * 0.1) * 2;
            mainCamera.position.y = 35 + Math.cos(animationTimeValue * 0.15) * 1;
            mainCamera.lookAt(0, 0, 0);
            
            // Render the updated scene
            webGLRenderer.render(animationScene, mainCamera);
        }

        // Start the animation loop
        runAnimationLoop();

        // Handle window resize events for responsive behavior
        window.addEventListener('resize', () => {
            mainCamera.aspect = window.innerWidth / window.innerHeight;
            mainCamera.updateProjectionMatrix();
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
